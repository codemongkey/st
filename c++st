所有头文件要能够自给自足。换言之,用户和重构工具不需要为特别场合而包含额外的头文件。详言之,一个头文件要有
define-guard ,统统包含它所需要的其它头文件,也不要求定义任何特别 symbols.
如果.h文件声明了一个模板或内联函数,同时也在该文件加以定义
如果某函数模板为所有相关模板参数显式实例化,或本身就是某类的一个私有成员,那么它就只能定义在实例化
该模板的  .cc  文件里。
所有头文件都应该使用  #define  来防止头文件被多重包含, 命名格式当是:  <PROJECT>_<PATH>_<FILE>_H_  .


尽可能地避免使用前置声明。使用  #include  包含需要的头文件即可。

如果dir/foo.c的主要作用是实现或者测试dir2/foo2.h的功能，foo.c中包含头文件的次序如下：
* 1.dir2/foo2.h（优先位置）
* 2.C系统文件
* 3.C++系统文件
* 4.其他库的.h文件
* 5.本项目内的.h文件
内联那些包含循环或  switch  语句的函数常常是得不偿失 

举例来说,  google-awesome-project/src/foo/internal/fooserver.cc  的包含次序如下:
#include "foo/public/fooserver.h" // 优先位置
#include <sys/types.h>
#include <unistd.h>
#include <hash_map>
#include <vector>
#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/public/bar.h"

比如虚函数和递归函数就不会被正常内联. 通常, 递
归函数不应该声明成内联函数.虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文
档描述其行为, 比如精短的存取函数.

有时,平台特定(system­specific)代码需要条件编译(conditional includes),这些代码可以放到其它 includes 之后。当
然,您的平台特定代码也要够简练且独立,比如:
#include "foo/public/fooserver.h"
#include "base/port.h"
// For LANG_CXX11.
#ifdef LANG_CXX11
#include <initializer_list>
#endif
// LANG_CXX11


在匿名空间的变量或者函数只在当前源文件内有效。

所有声明都置于命名空间中注意不要使用缩进

最好不要使用 using 指示,以保证名字空间下的所有名称都可以正常使用.
// 禁止——污染名字空间
using namespace foo;
在  .cc  文件,  .h  文件的函数, 方法或类中, 可以使用 using 声明。
// 允许: .cc 文件中
// .h 文件的话, 必须在函数, 方法或类的内部使用
using ::foo::bar;
嵌套类只能在外围类的内部做前置声明. 因此, 任何使用了  Foo::Bar*  指针的头文件不得不包含类Foo的整个声明.
不要将嵌套类定义成公有, 除非它们是接口的一部分, 比如, 嵌套类含有某些方法的一组选项.
些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在名字空间内可避免污染全局作用域.
如果你必须定义非成员函数, 又只是在  .cc  文件中使用它, 可使用匿名 namespaces 或  static  链接关键字 (如
static int Foo() {...} ) 限定其作用域.
C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是,应使用初始化的方式替代声明再赋值, 比如:

静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是不确定的,甚至随着构建变化而变化,导致难以发现的 bug. 所以
除了禁用类类型的全局变量,我们也不允许用函数返回值来初始化 POD 变量,除非该函数不涉及(比如 getenv() 或
getpid())不涉及任何全局变量。(函数作用域里的静态变量除外,毕竟它的初始化顺序是有明确定义的,而且只会在指令执
行到它的声明那里才会发生。)

综上所述,我们只允许 POD 类型的静态变量,即完全禁用  vector  (使用 C 数组替代) 和  string  (使用  const char
[] )。
静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是不确定的
综上所述,我们只允许 POD 类型的静态变量,即完全禁用  vector  (使用 C 数组替代) 和  string  (使用  const char
[] )。
如果您确实需要一个  class  类型的静态或全局变量,可以考虑在  main()  函数或  pthread_once()  内初始化一个指针且永不回收。注意只能用 raw 指针,别用智能指针,毕竟后者的析构函数涉及到上文指出的不定顺序问题。

成员变量初始化的顺序为：先进行声明时初始化，然后进行初始化列表初始化，最后进行构造函数初始化


通常, 如果构造函数只有一个参数, 可看成是一种隐式转换. 打个比方, 如果你定义了  Foo::Foo(string name) , 接着把
一个字符串传给一个以  Foo  对象为参数的函数, 构造函数  Foo::Foo(string name)  将被调用, 并将该字符串转换为
一个  Foo  的临时对象传给调用函数. 看上去很方便, 但如果你并不希望如此通过转换生成一个新对象的话, 麻烦也随之
而来. 为避免构造函数被调用造成隐式转换, 可以将其声明为  explicit .
除单参数构造函数外, 这一规则也适用于除第一个参数以外的其他参数都具有默认参数的构造函数, 例如
Foo::Foo(string name, int id = 42).
/usr/lib/x86_64-linux-gnu/qt4/bin
/usr/lib/x86_64-linux-gnu
当初始化列表用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化值存在丢失信息的风险，则编译器将报错：
=default 	  =delete(特化时可以使用)
如果派生类的构造函数只是调用基类的构造函数而没有其他行为时, 这一功能特别有用.
using Base::Base;

只在能够减少冗余代码, 提高可读性的前提下使用委派和继承构造函数. 如果派生类有新的成员变量, 那么使用继承构造
函数时要小心. 如果在派生类中对成员变量使用了类内部初始化的话, 继承构造函数还是适用的.
struct 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取
功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, Initialize(), Reset(), Validate() 等类似的函数外, 不能
提供其它功能的函数.

为了和 STL 保持一致, 对于仿函数和 trait 特性可以不用 class 而是使用 struct.
 除了异常类等个别情况（不希望用户把该类看作一个普通的、正常的类之情况）外，C++类/结构的命名应该遵循以下准则：
　
C++类/结构的命名	类的名称都要以大写字母“C”开头，后跟一个或多个单词。为便于界定，每个单词的首字母要大写。　
推荐的组成形式	类的命名推荐用"名词"或"形容词＋名词"的形式，例如："CAnalyzer", "CFastVector" ....


        不同于C++类的概念，传统的C结构体只是一种将一组数据捆绑在一起的方式。传统C结构体的命名规则为：

传统C结构体的命名	传统C结构体的名称全部由大写字母组成，单词间使用下划线界定，例如："SERVICE_STATUS", "DRIVER_INFO" ....

所有继承必须是  public  的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.
不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” 的情况下使用继承: 如果  Bar  的确 “是一种” Foo,
Bar  才能继承  Foo .
必要的话, 析构函数声明为  virtual . 如果你的类有虚函数, 则析构函数也应该为虚函数. 注意  数据成员在任何情况下都
必须是私有的 <....> _.
当重载一个虚函数, 在衍生类中把它明确的声明为  virtual . 理论依据: 如果省略  virtual  关键字, 代码阅读者不得不
检查所有父类, 以判断该函数是否是虚函数.

真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它
基类都是以  Interface  为后缀的 纯接口类.
考虑： 如果有两个这样的单例类，将分别生成单例对象A, 单例对象B. 它们分别定义在不同的编译单元（cpp中）， 而A的初始化依赖于B 【 即A的构造函数中要调用B::GetInstance() ，而此时B::m_instance 可能还未初始化，显然调用结果就是非法的 】， 所以说只有B在A之前完成初始化程序才能正确运行，而这种跨编译单元的初始化顺序编译器是无法保证的。

DCL有一个指令重排的问题

但是在C++11却是线程安全的，这是因为新的C++标准规定了当一个线程正在初始化一个变量的时候，其他线程必须得等到该初始化完成以后才能访问它.
假如线程A进入锁内并分配对象的空间，但是由于指令可能乱序，实际上导致local_instance被先指向一块未被分配的内存，然后再在这块内存上进程初始化。但是在指向后，未初始化前，另一线程B可能通过getInstance获取到这个指针。
原子操作是不可分割的，在执行完毕之前不会被任何其它任务或事件中断。

这是Test1和Test2在不同的线程中并发执行,有可能a和b字段的值都是0(尽管在x和y上应用了volatile关键字).这段代码的意思是说,即使使用了volatile,也无法保证操作的顺序不被交换.volatile关键字可以确保线程读取到最新的值,但保证不了操作顺序.
在这份代码中，虽然temp是volatile，但是*temp不是，其成员也不是。所以仍然可能被优化。尝试将其*temp也声明为volatile，你会发现的的代码充满了volatile。但是至少是正确的：

当一个类满足以下要求时, 称之为纯接口:
只有纯虚函数 (“ =0 “) 和静态函数 (除了下文提到的析构函数).
没有非静态数据成员.
没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为  protected .
如果它是一个子类, 也只能从满足上述条件并以  Interface  为后缀的类继承.
接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数
因为&操作符允许对没有明确定义的类进行操作，前置声明一个类并对其进行&操作时，行为是未定义的
该编译单元并不知道这个类重载了&操作符，可能会当成普通的取地址符进行操作(通过函数实现)
一般在头文件中把存取函数定义成内联函数.
类的访问控制区段的声明顺序依次为:  public: ,  protected: ,  private: . 如果某区段没内容, 可以不声明.
每个区段内的声明通常按以下顺序:
typedefs  和枚举
常量
构造函数
析构函数
成员函数, 含静态成员函数
数据成员, 含静态数据成员
友元声明应该放在 private 区段. 如果用宏 DISALLOW_COPY_AND_ASSIGN 禁用拷贝和赋值, 应当将其置于 private 区
段的末尾, 也即整个类声明的末尾. 参见可拷贝类型和可移动类型.
我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序
结构的前提下对其进行分割.
有时候,在输入形参中用  const T*  指针比  const T&  更明智。比如:
您会传 null 指针。
事实上这在 Google Code 是一个硬性约定: 输入参数是值参或  const  引用, 输出参数为指针. 输入参数可以是  const
指针, 但决不能是非  const  的引用参数,除非用于交换,比如  swap() .
函数要把指针或对地址的引用赋值给输入形参。
总之大多时候输入形参往往是  const T&
只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用  std::forward .
只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用  std::forward  功能函数. 你可能会使用
std::move  来表示将值从一个对象移动而不是复制到另一个对象.
如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如,用  AppendString()  和  AppendInt()  等,
而不是一口气重载多个  Append() .
缺省参数会干扰函数指针,害得后者的函数签名(function signature)往往对不上所实际要调用的函数签名
函数带默认值，他的指针是不可能把这种默认值带过去的。默认值是编译期信息，而你要的是运行时的默认值，这在函数指针是不可实现的。
唯一可以做到的是用functor，用一个函数类对象实现。如果一个类实现了()运算符，他就可以象一个函数来用，而对于你的要求，可以通过实现不同版本的()实现

缺省参数会干扰函数指针,害得后者的函数签名(function signature)往往对不上所实际要调用的函数签名。即在一个
现有函数添加缺省参数,就会改变它的类型,那么调用其地址的代码可能会出错,不过函数重载就没这问题了。此外,
缺省参数会造成臃肿的代码,毕竟它们在每一个调用点(call site)都有重复(acgtyrant 注:我猜可能是因为调用函数
的代码表面上看来省去了不少参数,但编译器在编译时还是会在每一个调用代码里统统补上所有默认实参信息,造成大
量的重复)。函数重载正好相反,毕竟它们所谓的「缺省参数」只会出现在函数定义里。


由于缺点并不是很严重,有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况,我们要求必须显式提供所有参数
(acgtyrant 注:即不能再通过缺省参数来省略参数了)。  
其一,位于  .cc  文件里的静态函数或匿名空间函数,毕竟都只能在局部文件里调用该函数了。
其二,可以在构造函数里用缺省参数,毕竟不可能取得它们的地址。
其三,可以用来模拟变长数组。
alloca() 和栈上的变长数组的区别在于，alloca() 的分配的内存有效范围是在整个函数内部，而变长数组的有效范围是 { } 之间，例如：

void func(void)
{
    int *p = NULL;
    if (xxx) {
        p = alloca(sizeof(int)); /* alloca分配的内存在if语句外也可以使用. */
        int arr[n]; /* arr的有效范围在if语句内. */
        ...
    }
    ...
}

不过需要注意的是，如果alloca和变长数组在同一个函数里混用时，当一个变长数组被销毁时，在他之后调用的alloca分配的内存也将被销毁。这是gcc manual中的原文：

If you use both variable-length arrays and alloca in the same function, deallocation of a variable-length array will also deallocate anything more recently allocated with alloca.

这点很好理解，变长数组和alloca都是在栈上分配内存，编译器在对栈上的变量销毁时只是简单的弹栈，如下：

if (xxx) {
   int arr[n];
   p = alloca(xxx);
}

上面这段代码执行时栈的变化：

      |   |       top-->|   |             |   |
top-->|   |             | p |             | p |已经无效了！
      |arr|             |arr|             |arr|弹栈，销毁arr
      |...|             |...|       top-->|...|
      +---+             +---+             +---+
(1)分配arr空间      (2)分配p的空间       (3)销毁arr时p同时被销毁
因此，虽然alloca和变长数组可以给我们带来方便，但使用时一定要小心！
通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将
FooBuilder  声明为  Foo  的友元, 以便  FooBuilder  正确构造  Foo  的内部状态, 而无需将该状态暴露出来. 某些情况
下, 将一个单元测试类声明成待测类的友元会很方便
异常是处理构造函数失败的唯一途径。虽然可以用工厂函数(acgtyrant 注:factory function, 出自 C++ 的一种设计模
式,即「简单工厂模式」)或  Init()  方法代替异常, but these require heap allocation or a new “invalid” state,
respectively.

在现有函数中添加  throw  语句时,您必须检查所有调用点。要么让所有调用点统统具备最低限度的异常安全保证,要
么眼睁睁地看异常一路欢快地往上跑,最终中断掉整个程序。举例, f()  调用  g() ,  g()  又调用  h() , 且  h  抛出的
异常被  f  捕获。当心  g , 否则会没妥善清理好。
从表面上看来,使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码, 引入异常会牵连到所有相关代码. 如果新项
目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++ 代码都没有异
常处理, 引入带有异常处理的新代码相当困难.
我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上. 我们希望在 Google 使用我们自己的开源项目, 但
项目中使用异常会为此带来不便, 因此我们也建议不要在 Google 的开源项目中使用异常. 如果我们需要把这些项目推倒
重来显然不太现实.

RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用  typeid  或者  dynamic_cast  完成.
我们禁止使用 RTTI.

在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你
的类.
随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者 switch 语句散布在代码各处. 如果以后要进行
修改, 你就必须检查它们.
在单元测试中可以使用 RTTI, 但是在其他代码中请尽量
避免. 尤其是在新代码中, 使用 RTTI 前务必三思. 如果你的代码需要根据不同的对象类型执行不同的行为的话, 请考虑用
以下的两种替代方案之一查询类型:
虚函数可以根据子类类型的不同而执行不同代码. 这是把工作交给了对象本身去处理.如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式. 这就能够在对象之外进行
类型判断.
如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 dynamic_cast. 在这种情况下, 使
用 dynamic_cast 也是一种替代方案.
基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样:
if (typeid(*data) == typeid(D1)) {
...
} else if (typeid(*data) == typeid(D2)) {
...
} else if (typeid(*data) == typeid(D3)) {
...
一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受
影响的代码块.
不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且, 这
些方案会掩盖你的真实意图.
使用 C++ 的类型转换, 如  static_cast<>() . 不要使用  int y = (int)x  或  int y = int(x)  等转换方式;
C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如  (int)3.5 ), 有时是在做类型转换 (如
(int)"hello" ). 另外, C++ 的类型转换在查找时更醒目.
只在记录日志时使用流.
定义:
流用来替代  printf()  和  scanf() .
简单性原则告诫我们必须从中选择其一, 最后大多数决定采用
printf + read/write .
不要使用流, 除非是日志接口需要. 使用  printf  之类的代替.
使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.

const  是入侵性的: 如果你向一个函数传入  const  变量, 函数原型声明中也必须对应  const  参数 (否则变量需要
const_cast  类型转换), 在调用库函数时显得尤其麻烦.
const  的位置, 有人喜欢  int const *foo  形式, 不喜欢  const int* foo , 他们认为前者更一致因此可读性也更好:
遵循了  const  总位于其描述的对象之后的原则. 但是一致性原则不适用于此, “不要过度使用” 的声明可以取消大部分你
原本想保持的一致性. 将  const  放在前面才更易读, 因为在自然语言中形容词 ( const ) 是在名词 ( int ) 之前.
这是说, 我们提倡但不强制  const  在前. 但要保持代码的一致性!

在 C++11 里,用 constexpr 来定义真正的常量,或实现常量初始化
定义:
变量可以被声明成 constexpr 以表示它是真正意义上的常量,即在编译时和运行时都不变。函数或构造函数也可以被声
明成 constexpr, 以用来定义 constexpr 变量。
优点:
如今 constexpr 就可以定义浮点式的真・常量,不用再依赖字面值了;也可以定义用户自定义类型上的常量;甚至也可
以定义函数调用所返回的常量。缺点:
若过早把变量优化成 constexpr 变量,将来又要把它改为常规变量时,挺麻烦的;Current restrictions on what is
allowed in constexpr functions and constructors may invite obscure workarounds in these definitions.
结论:
靠 constexpr 特性,方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 constexpr 来定义真・常量以及支持
常量的函数。Avoid complexifying function definitions to enable their use with constexpr. 千万别痴心妄想地想靠
constexpr 来强制代码「内联」。
constexpr int k=10;
  C++11允许声明constexpr类型来由编译器检验变量的值是否是一个常量表达式。声明为constexpr的必须是一个常量，并且只能用常量或者常量表达式来初始化。
一般来说，若果一旦认定变量是一个常量表达式，那就把它声明为constexpr类型

尽管指针和引用都可以定义为constexpr，但是他们的初始值却受到了严格的限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储某个固定地址的对象。函数体中定义的变量并非存放在固定地址中，因此constexpr指针不可以指向这样的变量。相反的，对于所有函数体之外的对象地址是固定不变的，可以用constexpr来定义；

必须明确一点，在constexpr声明中，如果定义了一个指针，限定符号constexpr仅仅对指针有效，与指针所指对象无关。

    const int *p=nullptr;  //p是一个指向整型常量的指针（pointer to const）

    constexpr int *p1=nullptr; //p1是一个常量指针(const pointer)




1、Find 命令

使用 Linux find 命令可以用不同的搜索标准如名字、类型、所属人、大小等来搜索目录树。基本语法如下：

# find path expression search-term 

下面是使用 find 命令根据文件名来查找特定文件的一个例子：

# find -name test.file 

命令会搜索整个目录树来查找名为 test.file 的文件，并且会提供其存放位置。你可以使用你 Linux 上一个存在的文件名来尝试一下。

find 命令有时会花费几分钟来查找整个目录树，尤其是如果系统中有很多文件和目录的话。要显著减少时间，你可以指定搜索的目录。比如，如果你知道 /var 中存在 test.file，那就没有必要搜索其它目录。这样，你可以使用下面的命令：

# find /var -name test.file 

find 还可以根据时间、大小、所属人、权限等选项搜索文件。要了解更多关于这些选项的信息，你可以使用查看** Linux find 命令**的手册。

# man find 

2、locate 命令

要在Linux中使用locate命令，首先需要安装它。

如果你正在使用 Ubuntu，运行下面的命令来安装 locate：

# apt-get update # apt-get install mlocate 

如果你使用的是 CentOS ，运行下面的命令来安装 locate：

# yum install mlocate 

locate 是一种比 find 更快的方式，因为它在数据库中查找文件。要更新搜索数据库，运行下面的命令：



反斜线符号“ \ ”在Bash中被解释为转义字符，用于去除一个单个字符的特殊意义，它保留了跟随在之后的字符的字面值，除了换行符。如果在反斜线之后一个换行字符立即出现，转义字符使行得以继续，遇到命令很长时使用反斜线很有效；反斜线从输入流中被移除并有效地忽略。

错误原因
重复定义

解决方法
打开QT工程文件*.pro

查看SOURCES += \ 以及 HEADERS += \

下方是否有重复的源文件名或头文件名，删掉重复的即可


异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。
对于通知调用者的三种方式，具体如下：

状态
即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。

通知
当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。

回调
与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。


for( itVec = Vec.begin(); itVec != Vec.end(); )
{
      if( WillDelete( *itVec) )
      {
          itVec = Vec.erase( itVec);
       }
      else
          itList++;
}
复制代码
 

      对vector、queue等，每次erase操作，函数会删除指定迭代器位置的元素，然后将后面的元素前移一位，erase返回指向被删除元素下一元素的迭代器。（其实，我认为，返回的还是指定的迭代器，只不过它现在指向了被删除元素的下一元素，如有不对，恳请大家指正！）

     对于erase操作，还有一种写法是：

Vec.erase(itVec++)
不过需要注意，这种写法对vector、deque等容器无效！

上面两种写法，第一种对各种容器都有效，第二种写法只对map，list等容器有效。为了方便统一，还是建议采取第一种写法。

not
逻辑非, 等价于操作符 !

上述代码就使用了类型获取功能。和函数返回值后置语法结合起来，可以有如下应用：
[cpp] view plaincopy

template <typename Builder>  
auto  
makeAndProcessObject (const Builder& builder) -> decltype( builder.makeObject() )  
{  
    auto val = builder.makeObject();  
    // do stuff with val  
    return val;  
}  

前面的例子中这个函数的返回值是void，所以不需要为返回值引入泛型。如果返回值是makeObject的返回值的话，那么这个函数就得引入两个泛型。现在又了类型获取功能，我们就能在返回值中自动推断makeObject的类型了。所以decltype确实为我们提供了很大的便利。

这个功能非常重要，在很多时候，尤其是引入了泛型编程的时候，你可能记不住一个变量的类型或者类型太过复杂以至于写不出来。你就要灵活使用decltype来获取这个变量的类型。



grep [option] pattern file



如果你想要将该对象交给另一个对象，就必须调用move函数，也就是说你必须放弃掉该对象的拥有权。

如：

v.push_back( std::move(q) );
执行完上述语句之后，q已经变成空的了，因为q已经放弃了该对象的拥有权，将拥有权交给了容器。
process( std::unique_ptr<foo>( new foo(41) ) );


当你在使用unqiue_ptr的时候。你发现你现在需要的是一个底层的指针，那么有两种方式：

do_something( q.get() );          //retain ownership
do_something_else( q.release() ); //give up ownership

get函数是不会转交拥有权的。 因此在大多数情况下get 函数是不提倡使用的。因为你一旦将unique_ptr包裹的真正的指针释放给函数使用了，那么你就很难控制该函数到底会对这个指针做些什么操作。也就是说你必须对你的函数谨慎再谨慎，以保证该函数只是简单的借用一下该指针而已。
而release函数则是一个比较靠谱的方式了，当你向上述一样对指针q调用 release时，其实你就已经宣称说：该对象已经不归我管了，现在就是你的了。

还有，当unique_ptr作为引用对象传递给函数的时候，如下：

void inc_baz( std::unique_ptr<foo> &p )
{
    p->baz++;
}

因为是传引用，所以你完全不必要担心该指针会被复制或者模糊了拥有者之类的事情了。


关于unique_ptr的使用，其实我们只需要在代码中多多的使用auto关键字来做类型推断，那么实际上我们在改写自己的代码来使用unqiue_ptr的时候，我们不需要改变更多的用户代码。














